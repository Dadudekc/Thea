#!/usr/bin/env python3\n\"\"\"\nStandalone tool to generate a task_list.md file by scanning a Python source file\nfor TODO comments, pass statements, and NotImplementedErrors.\n\nUsage:\n  python generate_task_list_from_code.py <PYTHON_FILE_PATH> [--output <OUTPUT_MD_PATH>]\n\nExample:\n  python tools/generate_task_list_from_code.py ../agents/some_agent.py --output ../agents/some_agent_task_list.md\n  python tools/generate_task_list_from_code.py ../core/main_logic.py # Prints to stdout\n\"\"\"\n\nimport ast\nimport re\nimport argparse\nimport io\nfrom pathlib import Path\nfrom datetime import datetime\n\n# Regex to find TODO comments (case-insensitive)\nTODO_REGEX = re.compile(r\"#\s*TODO[:\s]*(.*)\", re.IGNORECASE)\n\nclass CodeAnalyzer(ast.NodeVisitor):\n    \"\"\"Visits AST nodes to find points of interest.\"\"\"\n    def __init__(self):\n        self.findings = {\n            \"pass_statements\": [],\n            \"not_implemented\": [],\n            \"empty_bodies\": []\n        }\n\n    def visit_FunctionDef(self, node):\n        # Check for empty body or just a docstring + pass/NotImplementedError\n        if not node.body:\n            self.findings[\"empty_bodies\"].append((node.name, node.lineno))\n        elif len(node.body) == 1:\n            if isinstance(node.body[0], ast.Pass):\n                self.findings[\"pass_statements\"].append((node.name, node.lineno))\n            elif isinstance(node.body[0], ast.Raise) and \\\n                 isinstance(node.body[0].exc, ast.Call) and \\\n                 isinstance(node.body[0].exc.func, ast.Name) and \\\n                 node.body[0].exc.func.id == \'NotImplementedError\':\n                self.findings[\"not_implemented\"].append((node.name, node.lineno))\n            elif isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Constant) and isinstance(node.body[0].value.value, str):\n                 # Just a docstring, effectively empty\n                 self.findings[\"empty_bodies\"].append((node.name, node.lineno))\n        elif len(node.body) == 2:\n             # Check for docstring + pass or NotImplementedError\n             if isinstance(node.body[0], ast.Expr) and isinstance(node.body[0].value, ast.Constant) and isinstance(node.body[0].value.value, str):\n                  if isinstance(node.body[1], ast.Pass):\n                      self.findings[\"pass_statements\"].append((node.name, node.lineno))\n                  elif isinstance(node.body[1], ast.Raise) and \\\n                       isinstance(node.body[1].exc, ast.Call) and \\\n                       isinstance(node.body[1].exc.func, ast.Name) and \\\n                       node.body[1].exc.func.id == \'NotImplementedError\':\n                      self.findings[\"not_implemented\"].append((node.name, node.lineno))\n        \n        # Ensure we visit nested functions\n        self.generic_visit(node)\n\n    # Also check AsyncFunctionDef\n    visit_AsyncFunctionDef = visit_FunctionDef\n\ndef find_todos(code_content: str):\n    \"\"\"Finds TODO comments in the code content.\"\"\"\n    todos = []\n    for i, line in enumerate(code_content.splitlines()):\n        match = TODO_REGEX.search(line)\n        if match:\n            todos.append((match.group(1).strip(), i + 1))\n    return todos\n\ndef generate_report(file_path: Path, todos: list, analyzer_findings: dict, output_file: Path | None):\n    \"\"\"Generates the Markdown report to stdout or a file.\"\"\"\n    report = io.StringIO()\n    \n    report.write(f\"# Task List: Code Analysis for `{file_path.name}`\n\")\n    report.write(f\"Generated: {datetime.utcnow().strftime(\'%Y-%m-%d %H:%M:%S UTC\')}\n\n\")\n    report.write(f\"Analyzed File: `{file_path.resolve()}`\n\n\")\n    \n    has_findings = False\n\n    if todos:\n        has_findings = True\n        report.write(\"## I. TODO Comments\n\n\")\n        for comment, line_num in todos:\n            report.write(f\"- [ ] **L{line_num}:** {comment}\n\")\n        report.write(\"\\n\")\n        \n    if analyzer_findings[\"not_implemented\"]:\n        has_findings = True\n        report.write(\"## II. NotImplementedError Found\n\n\")\n        for name, line_num in sorted(analyzer_findings[\"not_implemented\"], key=lambda x: x[1]):\n            report.write(f\"- [ ] **L{line_num} (`{name}`):** Function/Method raises `NotImplementedError`.\n\")\n        report.write(\"\\n\")\n        \n    if analyzer_findings[\"pass_statements\"]:\n        has_findings = True\n        report.write(\"## III. `pass` Statements Found (Potential Stubs)\n\n\")\n        for name, line_num in sorted(analyzer_findings[\"pass_statements\"], key=lambda x: x[1]):\n            report.write(f\"- [ ] **L{line_num} (`{name}`):** Function/Method contains only `pass` (or docstring + `pass`). Review implementation.\n\")\n        report.write(\"\\n\")\n        \n    if analyzer_findings[\"empty_bodies\"]:\n        has_findings = True\n        report.write(\"## IV. Empty Function/Method Bodies Found\n\n\")\n        for name, line_num in sorted(analyzer_findings[\"empty_bodies\"], key=lambda x: x[1]):\n            report.write(f\"- [ ] **L{line_num} (`{name}`):** Function/Method body is empty (or contains only a docstring). Implement or remove.\n\")\n        report.write(\"\\n\")\n        \n    if not has_findings:\n         report.write(\"**✅ No obvious TODOs, `pass` statements, `NotImplementedError` instances, or empty bodies found.**\n\")\n\n    # Output the report\n    report_content = report.getvalue()\n    if output_file:\n        try:\n            with open(output_file, \"w\", encoding=\"utf-8\") as f:\n                f.write(report_content)\n            print(f\"✅ Report generated: {output_file.resolve()}\")\n        except Exception as e:\n            print(f\"❌ Error writing report to {output_file}: {e}\")\n            print(\"\\n--- Report Content ---\")\n            print(report_content) # Print to stdout as fallback\n    else:\n        print(report_content)\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Generate a task list from TODOs and stubs in a Python file.\")\n    parser.add_argument(\"python_file\", help=\"Path to the Python source file to analyze.\")\n    parser.add_argument(\"--output\", help=\"Optional path to save the Markdown report. If omitted, prints to stdout.\")\n\n    args = parser.parse_args()\n\n    py_file_path = Path(args.python_file).resolve()\n    output_path = Path(args.output).resolve() if args.output else None\n\n    if not py_file_path.is_file():\n        print(f\"❌ Error: Python file not found: {py_file_path}\")\n        exit(1)\n        \n    if output_path and not output_path.parent.is_dir():\n        print(f\"❌ Error: Output directory does not exist: {output_path.parent}\")\n        exit(1)\n\n    try:\n        with open(py_file_path, \"r\", encoding=\"utf-8\") as f:\n            source_code = f.read()\n    except Exception as e:\n        print(f\"❌ Error reading Python file {py_file_path}: {e}\")\n        exit(1)\n\n    # Find TODOs\n    todos = find_todos(source_code)\n\n    # Analyze AST\n    analyzer = CodeAnalyzer()\n    try:\n        tree = ast.parse(source_code)\n        analyzer.visit(tree)\n    except SyntaxError as e:\n        print(f\"❌ Error: Failed to parse Python file (SyntaxError): {e}\")\n        # Optionally still generate report with only TODOs?\n        analyzer_findings = {\"pass_statements\": [], \"not_implemented\": [], \"empty_bodies\": []} # Empty findings\n        generate_report(py_file_path, todos, analyzer_findings, output_path) \n        exit(1)\n    except Exception as e:\n        print(f\"❌ Error during AST analysis: {e}\")\n        exit(1)\n\n    # Generate the report\n    generate_report(py_file_path, todos, analyzer.findings, output_path)\n 