# Bridge Intelligence Report for Agent-5

**Generated By:** Captain-THEA (via Research Assistant Directive)
**Date:** {{iso_timestamp_utc()}}
**Subject:** Analysis of the ChatGPT-to-Cursor Bridge Architecture

## 1. Overview

This report summarizes the components, control flow, configuration, testing gaps, historical context, and potential extension points for the ChatGPT-to-Cursor Bridge, based on codebase analysis and project artifact review. The primary goal is to consolidate system understanding to aid Agent-5.

## 2. Core Components & Functionality

The main GUI-based bridge logic appears centralized in `src/dreamos/automation/cursor_orchestrator.py`.

*   **`CursorOrchestrator` (Singleton Class):**
    *   **Purpose:** Manages interactions with one or more Cursor GUI instances associated with specific agent IDs. Handles prompt injection and response retrieval via direct UI automation.
    *   **Key Methods:**
        *   `__init__(config: AppConfig, ...)`: Initializes, loads coordinates from config (`gui_automation` section), sets initial agent statuses (`IDLE`).
        *   `inject_prompt(agent_id, prompt, ...)`: Triggers the injection sequence. Publishes `CURSOR_INJECT_*` events.
        *   `retrieve_response(agent_id, ...)`: Triggers the retrieval sequence. Publishes `CURSOR_RETRIEVE_*` events.
        *   `_perform_injection_sequence(...)`: Handles UI automation for injection (click, type/paste, enter) using `pyautogui`/`pyperclip`. Includes focus checks (via `_check_and_recover_focus`) and retries (`tenacity`).
        *   `_perform_copy_sequence(...)`: Handles UI automation for retrieval (click copy button, read clipboard) using `pyautogui`/`pyperclip`. Includes retries.
        *   `_check_and_recover_focus(...)`: Attempts to find window by title (`config.gui_automation.target_window_title`) and activate it using `pygetwindow` (if available).
        *   `start_listening()` / `_handle_cursor_action_event()`: Listens for `CURSOR_ACTION_REQUEST` events on `AgentBus` to trigger injection/retrieval.
    *   **State:** Maintains `agent_status` (IDLE, INJECTING, etc.) and loaded `input_coordinates`/`copy_coordinates`.
    *   **Dependencies:** `pyautogui`, `pyperclip`, `tenacity`, `AppConfig`, `AgentBus`, `pygetwindow` (optional).

*   **Supporting Modules (Assumed/Inferred due to timeouts reading files):**
    *   `src/dreamos/integrations/cursor/window_controller.py`: Likely handles finding, activating, and potentially managing multiple Cursor windows based on title. Used by `_check_and_recover_focus`.
    *   `src/dreamos/utils/gui_utils.py`: Contains helpers like `wait_for_element` (imported by orchestrator).
    *   `src/dreamos/utils/decorators.py`: Contains the `retry_on_exception` decorator used in the orchestrator.

*   **Alternative/Separate Systems:**
    *   `src/dreamos/agents/cursor_dispatcher.py`: Appears to manage tasks for *headless* Cursor instances launched via `VirtualDesktopController`, using file-based queues (`task_queue.json`) and Jinja2 templates. Seems distinct from the GUI `CursorOrchestrator`.
    *   `src/dreamos/integrations/agent_services/cursor_shadow_controller.py`: Implements interaction via a file-based inbox/outbox (`.prompt.txt`, `.result.json`). Likely for background/non-GUI agents.

## 3. Control Flow (GUI Bridge via Orchestrator)

1.  Request received via `AgentBus` (`CURSOR_ACTION_REQUEST`) or direct call (`inject_prompt`/`retrieve_response`).
2.  Orchestrator updates agent status (`INJECTING`/`COPYING`) and publishes request event.
3.  Retrieves relevant coordinates (input/copy) for the target `agent_id`.
4.  Calls `_perform_injection_sequence` or `_perform_copy_sequence`.
5.  UI Automation Sequence:
    *   Checks/recovers window focus (`_check_and_recover_focus`).
    *   Clicks target coordinates (`pyautogui.click`).
    *   Injects text (`pyautogui.write` or `pyperclip.copy`/`pyautogui.hotkey('ctrl', 'v')`).
    *   Presses Enter (`pyautogui.press('enter')`) OR reads clipboard (`pyperclip.paste`).
    *   Includes retries on failure.
6.  Orchestrator updates agent status (`AWAITING_RESPONSE`/`IDLE` or `ERROR`).
7.  Orchestrator publishes result event (`CURSOR_INJECT_SUCCESS`/`FAILURE` or `CURSOR_RETRIEVE_SUCCESS`/`FAILURE`).

## 4. Configuration Hooks

*   **`AppConfig` (`gui_automation` section):**
    *   `input_coords_file_path`: Path to JSON input coordinates file.
    *   `copy_coords_file_path`: Path to JSON copy coordinates file.
    *   `default_timeout`, `retry_attempts`, `retry_delay`: Parameters for retry logic.
    *   `use_clipboard_paste`: Controls injection method (typing vs. pasting).
    *   `target_window_title`: Used for focus checking.
*   **Potential Env Vars:** Via `AppConfig` (Pydantic `BaseSettings`).
*   **Hardcoded:** Some minor `time.sleep` delays within UI sequences.

## 5. Testing Gaps & Considerations

*   **UI Automation:** Core injection/retrieval sequences (`_perform_injection_sequence`, `_perform_copy_sequence`) are highly dependent on `pyautogui`/`pyperclip` and screen state. Require mocking these libraries heavily for unit tests. Integration tests would need a controlled GUI environment.
*   **Focus/Window Management:** `_check_and_recover_focus` relies on `pygetwindow` and window titles, making it environment-specific. Mocking is essential for testing.
*   **Coordinates:** Correctness of external coordinate files cannot be unit tested. Functional/calibration tests are needed.
*   **Error/Retry Logic:** Testing requires simulating specific UI automation exceptions (`FailSafeException`, `PyperclipException`, `TimeoutError`).
*   **AgentBus:** Interactions need `AgentBus` mocking.
*   **Historical Blockers:** Tasks `IMPLEMENT-CURSOR-INJECTOR-002` and `IMPLEMENT-THEA-RESPONSE-READER-003` were blocked due to failures adding `pyautogui`, `pyperclip`, `Pillow`, `pytesseract` dependencies, potentially via automated `pyproject.toml` edits. Tesseract OCR also requires external installation.

## 6. Historical Context

*   **Completed Tasks:** `CORE-STABILIZE-CURSOR-LOOP-001`, `DEFINE-BRIDGE-ARCHITECTURE-001`.
*   **Blocked Tasks:** `IMPLEMENT-CURSOR-INJECTOR-002`, `IMPLEMENT-THEA-RESPONSE-READER-003` (due to dependency issues).
*   **Pending Tasks:** `VALIDATE-BRIDGE-CYCLE-004`, `AUTOMATE-BRIDGE-LOOP-005`.
*   **Git Log:** (Search popped to background, results unavailable but assume relevant commits exist).

## 7. Potential Extension Points (Speculative)

*   **Discord Triggering:** Agent listens to Discord, translates commands to `CURSOR_ACTION_REQUEST` events for the orchestrator.
*   **Dreamscape Integration:** Narrative engine sends drafts to Cursor for review/edit via injector, retrieves via reader.
*   **Multi-Agent Handling:** Implement internal queuing or dynamic assignment for multiple requests targeting the same/multiple Cursor instances.
*   **Alternative Extraction:** Implement OCR or Accessibility API-based response reading as fallbacks.
*   **Config Reloading:** Add mechanism to reload coordinate files dynamically.
*   **Enhanced Health Checks:** Inject "ping" prompt and verify specific "pong" response.

---
*End of Report*
