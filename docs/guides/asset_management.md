# Asset Management Guide

**Version:** 1.0
**Status:** DRAFT
**Date:** {{iso_timestamp_utc}}
**Related Standards:** [Task Management](../standards/task_management.md), [Naming Conventions](../standards/naming_conventions.md)

## 1. Overview

This guide defines the standard practices for managing non-code assets within the
Dream.OS project. Effective asset management ensures consistency, discoverability,
and prevents duplication or loss of necessary project resources.

Non-code assets include, but are not limited to:

- Images (icons, logos, diagrams)
- Templates (configuration file templates, message templates)
- Data files (JSON, YAML, CSV used for configuration, testing, or initial data)
- Documentation assets (e.g., embedded diagrams not generated by code)
- Design files (e.g., UI mockups - if stored in repo)
- Compiled assets (if applicable, e.g., CSS from SCSS - though build artifacts are often excluded from Git)

## 2. Standard Locations

To maintain organization, assets should be stored in designated directories.

- **`/assets/` (Root Level):**
    - General-purpose assets used across multiple components or system-wide.
    - Subdirectories should be created based on asset type or domain.
    - Examples:
        - `/assets/images/icons/`
        - `/assets/images/logos/`
        - `/assets/templates/config/`
        - `/assets/data/defaults/`

- **Component-Specific Assets:**
    - Assets used *only* by a specific component (e.g., a particular agent, a specific UI view) may be co-located within that component's directory structure.
    - Example: `src/dreamos/agents/example_agent/assets/prompt_templates/`
    - Use this sparingly to avoid scattering assets; prefer the root `/assets/` directory if an asset might have broader use later.

- **Documentation Assets:**
    - Images or diagrams used *only* within documentation should reside within the `/docs/` directory structure, typically in an `images` or `assets` subdirectory close to the referencing document.
    - Example: `/docs/architecture/images/swarm_diagram.png`

## 3. Naming Conventions

Asset file names **MUST** adhere to the project's [Naming Conventions Standard](../standards/naming_conventions.md).

- **Convention:** `kebab-case` (lowercase words separated by hyphens).
- **Clarity:** Names should be descriptive and clearly indicate the asset's purpose or content.
- **Avoid:** Generic names (`image1.png`, `data.json`), unnecessary abbreviations.

**Examples:**

- `user-avatar-default.png`
- `agent-config-template.yaml`
- `error-code-descriptions.json`
- `system-startup-flow.svg`

## 4. Asset Management Process

1.  **Identification:** When developing a feature or task, identify any required non-code assets early.
2.  **Location:** Determine the appropriate location based on Section 2 (root `/assets/` vs. component-specific).
3.  **Naming:** Name the asset file according to Section 3.
4.  **Dependency Tracking:**
    - While not formally tracked via structured fields in task definitions (see Task Management Standard), **explicitly note** dependencies on specific asset files in the task's `notes` field if the asset is critical for task completion or functionality.
    - If an asset needs to be created or acquired, a prerequisite task should ideally be created.
5.  **Versioning/Updates:**
    - Use Git for version control of assets stored in the repository.
    - If replacing an asset, consider whether the old version needs to be retained (rarely needed unless for rollback) or can be overwritten/deleted.
    - Major revisions to widely used assets (e.g., core templates) should be communicated.
6.  **Cleanup:** Periodically review assets, especially within component-specific directories, to identify and potentially remove unused or obsolete files. (This could be a recurring maintenance task).

## 5. Large Assets / Binary Files

- Avoid committing large binary files directly to the Git repository where possible, as this can significantly increase repository size.
- Consider using Git LFS (Large File Storage) if necessary for managing essential large binaries.
- For large datasets or build artifacts, explore external storage solutions or artifact repositories rather than Git.

## 6. Responsibility

- Agents or developers creating/modifying features are responsible for managing the associated assets according to this guide.
- Code reviewers should briefly check that new assets are placed and named correctly.
- The Captain (Agent-8) or designated leads oversee the overall structure and address major organizational issues.
