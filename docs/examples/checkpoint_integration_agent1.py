"""
Checkpoint Integration Example for Agent-1 (Captain Agent)

This script demonstrates how to integrate the CheckpointManager into the Captain Agent's
operational loop to prevent drift in long-running sessions.

Generated by: dreamos.utils.checkpoint_integration
Date: 2025-05-18
"""

import time
import logging
import os
import json
from pathlib import Path
from typing import Dict, Any, Optional

from dreamos.core.checkpoint_manager import CheckpointManager
from dreamos.utils.checkpoint_integration import (
    setup_checkpoint_system,
    check_and_create_checkpoint,
    controlled_restart,
    checkpoint_operation
)

# Configure logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("agent-1.captain")

class CaptainAgent:
    """
    Captain Agent implementation with checkpoint integration.
    
    This class demonstrates how to integrate checkpoint capabilities
    into the Captain Agent's operational logic.
    """
    
    def __init__(self):
        """Initialize the Captain Agent with checkpoint support."""
        self.agent_id = "Agent-1"
        self.role = "Captain"
        self.current_task_id = None
        self.current_task_status = None
        self.task_context = {}
        self.operational_context = {
            "goals": ["Ensure system stability", "Coordinate agent activities"],
            "decisions": []
        }
        self.memory = {
            "short_term": [],
            "session": []
        }
        
        # Initialize checkpoint system
        self.checkpoint_manager, self.last_checkpoint_time = setup_checkpoint_system(self.agent_id)
        self.session_start_time = time.time()
        
        # Customize checkpoint manager for Captain-specific state
        self._customize_checkpoint_manager()
        
    def _customize_checkpoint_manager(self):
        """Customize the checkpoint manager with Captain-specific state handlers."""
        # Store the original methods
        original_get_task_state = self.checkpoint_manager._get_current_task_state
        original_restore_task_state = self.checkpoint_manager._restore_task_state
        original_get_operational_context = self.checkpoint_manager._get_operational_context
        original_restore_operational_context = self.checkpoint_manager._restore_operational_context
        original_get_memory_state = self.checkpoint_manager._get_memory_state
        original_restore_memory_state = self.checkpoint_manager._restore_memory_state
        
        # Override with customized methods
        def get_task_state():
            # Try the default implementation
            state = original_get_task_state()
            
            # Add Captain-specific task state
            captain_state = {
                "id": self.current_task_id,
                "status": self.current_task_status,
                "progress_percentage": self._calculate_progress(),
                "context": self.task_context
            }
            
            # Merge with default state
            state.update(captain_state)
            return state
            
        def restore_task_state(task_state):
            # Use default implementation
            original_restore_task_state(task_state)
            
            # Add Captain-specific restoration
            if task_state:
                self.current_task_id = task_state.get("id")
                self.current_task_status = task_state.get("status")
                self.task_context = task_state.get("context", {})
                
        def get_operational_context():
            # Get default context
            context = original_get_operational_context()
            
            # Enhance with Captain-specific context
            captain_context = self.operational_context
            context.update(captain_context)
            return context
            
        def restore_operational_context(operational_context):
            # Use default implementation
            original_restore_operational_context(operational_context)
            
            # Add Captain-specific restoration
            if operational_context:
                self.operational_context = operational_context
                
        def get_memory_state():
            # Get default memory state
            memory = original_get_memory_state()
            
            # Enhance with Captain-specific memory
            captain_memory = self.memory
            memory.update(captain_memory)
            return memory
            
        def restore_memory_state(memory_state):
            # Use default implementation
            original_restore_memory_state(memory_state)
            
            # Add Captain-specific restoration
            if memory_state:
                self.memory = memory_state
                
        # Apply the customized methods
        self.checkpoint_manager._get_current_task_state = get_task_state
        self.checkpoint_manager._restore_task_state = restore_task_state
        self.checkpoint_manager._get_operational_context = get_operational_context
        self.checkpoint_manager._restore_operational_context = restore_operational_context
        self.checkpoint_manager._get_memory_state = get_memory_state
        self.checkpoint_manager._restore_memory_state = restore_memory_state
        
    def _calculate_progress(self) -> int:
        """Calculate task progress percentage based on Captain-specific logic."""
        # In a real implementation, this would calculate actual progress
        return 50  # Dummy value for example
    
    @checkpoint_operation
    def process_mailbox(self, checkpoint_manager):
        """
        Process Captain's mailbox with checkpoint protection.
        
        This function demonstrates how to use the checkpoint_operation decorator
        to automatically create checkpoints before and after critical operations.
        """
        logger.info("Captain processing mailbox...")
        
        # Simulate mailbox processing
        time.sleep(1)
        
        # Add to memory
        self.memory["short_term"].append({
            "action": "process_mailbox",
            "timestamp": time.time()
        })
        
        logger.info("Mailbox processing complete")
        
    def manage_agent_coordination(self):
        """Coordinate agent activities (simplified example)."""
        logger.info("Managing agent coordination...")
        
        # Creating a pre-operation checkpoint before coordination
        pre_op_checkpoint = self.checkpoint_manager.create_checkpoint("pre_operation")
        logger.info(f"Created pre-operation checkpoint: {pre_op_checkpoint}")
        
        try:
            # Simulate coordination work
            time.sleep(1)
            
            # Add decision to context
            self.operational_context["decisions"].append({
                "type": "coordination",
                "timestamp": time.time(),
                "detail": "Updated task assignments"
            })
            
            # Successful completion checkpoint
            post_op_checkpoint = self.checkpoint_manager.create_checkpoint("post_operation")
            logger.info(f"Created post-operation checkpoint: {post_op_checkpoint}")
            
        except Exception as e:
            # Create recovery checkpoint on error
            recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
            logger.error(f"Error during coordination: {str(e)}")
            logger.info(f"Recovery checkpoint created: {recovery_checkpoint}")
            
    def operational_loop(self):
        """
        Main operational loop with checkpoint integration.
        
        This demonstrates a complete integration of checkpointing into
        the Captain's operational loop.
        """
        logger.info("Starting Captain Agent operational loop...")
        
        # Main operational loop
        while True:  # In real implementation, there would be a proper exit condition
            try:
                # 1. Process mailbox
                self.process_mailbox(self.checkpoint_manager)
                
                # 2. Agent coordination
                self.manage_agent_coordination()
                
                # 3. Regular checkpoint creation
                self.last_checkpoint_time = check_and_create_checkpoint(
                    self.checkpoint_manager,
                    self.last_checkpoint_time
                )
                
                # 4. Check for session refresh to prevent drift
                current_time = time.time()
                if current_time - self.session_start_time >= 7200:  # 2 hours
                    logger.info("Session duration exceeds 2 hours, initiating controlled restart")
                    recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
                    controlled_restart(recovery_checkpoint)
                    break  # Exit loop after restart
                    
                # Simulate short delay between operations
                time.sleep(5)
                
            except Exception as e:
                # Create recovery checkpoint on error
                recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
                logger.error(f"Error during operation: {str(e)}")
                logger.info(f"Recovery checkpoint created: {recovery_checkpoint}")
                
                # Continue loop instead of breaking (resilience)
                continue
                
        logger.info("Captain Agent operational loop terminated")

if __name__ == "__main__":
    # Create and run the Captain Agent
    captain = CaptainAgent()
    captain.operational_loop() 