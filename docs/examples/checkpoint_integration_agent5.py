"""
Checkpoint Integration Example for Agent-5 (Task Agent)

This script demonstrates how to integrate the CheckpointManager into the Task Agent's
operational loop to prevent drift in long-running sessions.

Generated by: dreamos.utils.checkpoint_integration
Date: 2025-05-18
"""

import time
import logging
import os
import json
import copy
from typing import List, Dict, Any, Optional

from dreamos.core.checkpoint_manager import CheckpointManager
from dreamos.utils.checkpoint_integration import (
    setup_checkpoint_system,
    check_and_create_checkpoint,
    controlled_restart,
    checkpoint_operation
)

# Configure logging
logging.basicConfig(level=logging.INFO, 
                   format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("agent-5.task")

class TaskAgent:
    """
    Task Agent implementation with checkpoint integration.
    
    This class demonstrates how to integrate checkpoint capabilities
    into the Task Agent's operational logic, with special emphasis on
    preserving task management state.
    """
    
    def __init__(self):
        """Initialize the Task Agent with checkpoint support."""
        self.agent_id = "Agent-5"
        self.role = "Task System Engineer"
        self.current_task_id = None
        self.current_task_status = None
        self.task_context = {}
        
        # Task management specific state
        self.task_board = {
            "pending_tasks": [],
            "in_progress_tasks": [],
            "completed_tasks": []
        }
        self.task_metrics = {
            "task_completion_rate": 0.0,
            "average_completion_time": 0.0,
            "assignment_counts": {}
        }
        self.task_locks = set()
        
        self.memory = {
            "short_term": [],
            "session": []
        }
        
        # Initialize checkpoint system
        self.checkpoint_manager, self.last_checkpoint_time = setup_checkpoint_system(self.agent_id)
        self.session_start_time = time.time()
        
        # Customize checkpoint manager for task-specific state
        self._customize_checkpoint_manager()
        
    def _customize_checkpoint_manager(self):
        """Customize the checkpoint manager with task-specific state handlers."""
        # Store the original methods
        original_get_task_state = self.checkpoint_manager._get_current_task_state
        original_restore_task_state = self.checkpoint_manager._restore_task_state
        original_get_operational_context = self.checkpoint_manager._get_operational_context
        original_restore_operational_context = self.checkpoint_manager._restore_operational_context
        original_get_memory_state = self.checkpoint_manager._get_memory_state
        original_restore_memory_state = self.checkpoint_manager._restore_memory_state
        
        # Override with customized methods
        def get_task_state():
            # Try the default implementation
            state = original_get_task_state()
            
            # Add task agent-specific state
            task_agent_state = {
                "id": self.current_task_id,
                "status": self.current_task_status,
                "progress_percentage": self._calculate_progress(),
                "context": self.task_context,
                "task_board_snapshot": copy.deepcopy(self.task_board),
                "task_metrics": copy.deepcopy(self.task_metrics),
                "task_locks": list(self.task_locks)
            }
            
            # Merge with default state
            state.update(task_agent_state)
            return state
            
        def restore_task_state(task_state):
            # Use default implementation
            original_restore_task_state(task_state)
            
            # Add task agent-specific restoration
            if task_state:
                self.current_task_id = task_state.get("id")
                self.current_task_status = task_state.get("status")
                self.task_context = task_state.get("context", {})
                
                # Restore task board if available
                if "task_board_snapshot" in task_state:
                    self.task_board = task_state["task_board_snapshot"]
                    
                # Restore task metrics if available
                if "task_metrics" in task_state:
                    self.task_metrics = task_state["task_metrics"]
                    
                # Restore task locks if available
                if "task_locks" in task_state:
                    self.task_locks = set(task_state["task_locks"])
                
        def get_operational_context():
            # Get default context
            context = original_get_operational_context()
            
            # Enhance with task agent-specific context
            task_context = {
                "task_system_state": {
                    "total_tasks": len(self.task_board["pending_tasks"]) + 
                                  len(self.task_board["in_progress_tasks"]) + 
                                  len(self.task_board["completed_tasks"]),
                    "pending_count": len(self.task_board["pending_tasks"]),
                    "in_progress_count": len(self.task_board["in_progress_tasks"]),
                    "completed_count": len(self.task_board["completed_tasks"]),
                    "locked_tasks": list(self.task_locks)
                }
            }
            context.update(task_context)
            return context
            
        def restore_operational_context(operational_context):
            # Use default implementation
            original_restore_operational_context(operational_context)
            
            # No additional task agent-specific restoration needed for operational context
            pass
                
        def get_memory_state():
            # Get default memory state
            memory = original_get_memory_state()
            
            # Enhance with task agent-specific memory
            memory.update(self.memory)
            return memory
            
        def restore_memory_state(memory_state):
            # Use default implementation
            original_restore_memory_state(memory_state)
            
            # Add task agent-specific restoration
            if memory_state:
                self.memory = memory_state
                
        # Apply the customized methods
        self.checkpoint_manager._get_current_task_state = get_task_state
        self.checkpoint_manager._restore_task_state = restore_task_state
        self.checkpoint_manager._get_operational_context = get_operational_context
        self.checkpoint_manager._restore_operational_context = restore_operational_context
        self.checkpoint_manager._get_memory_state = get_memory_state
        self.checkpoint_manager._restore_memory_state = restore_memory_state
        
    def _calculate_progress(self) -> int:
        """Calculate task progress percentage based on task agent-specific logic."""
        # In a real implementation, this would calculate actual progress
        return 75  # Dummy value for example
        
    def _mock_load_tasks(self):
        """Load tasks from the task board files (mock implementation)."""
        # In a real implementation, this would load tasks from files
        # This is a simplified mock version for the example
        self.task_board = {
            "pending_tasks": [
                {"task_id": "TASK-001", "description": "Sample task 1", "priority": "Medium"},
                {"task_id": "TASK-002", "description": "Sample task 2", "priority": "High"}
            ],
            "in_progress_tasks": [
                {"task_id": "TASK-003", "description": "Sample task 3", "priority": "Critical", "assigned_to": "Agent-2"}
            ],
            "completed_tasks": [
                {"task_id": "TASK-004", "description": "Sample task 4", "priority": "Low", "completed_by": "Agent-1"}
            ]
        }
        
        # Calculate metrics
        self.task_metrics = {
            "task_completion_rate": 0.25,  # 1 out of 4 tasks completed
            "average_completion_time": 3600,  # 1 hour (mock value)
            "assignment_counts": {
                "Agent-1": 1,
                "Agent-2": 1
            }
        }
    
    @checkpoint_operation
    def process_mailbox(self, checkpoint_manager):
        """
        Process Task Agent's mailbox with checkpoint protection.
        
        This function demonstrates how to use the checkpoint_operation decorator
        to automatically create checkpoints before and after critical operations.
        """
        logger.info("Task Agent processing mailbox...")
        
        # Simulate mailbox processing
        time.sleep(1)
        
        # Add to memory
        self.memory["short_term"].append({
            "action": "process_mailbox",
            "timestamp": time.time()
        })
        
        logger.info("Mailbox processing complete")
        
    @checkpoint_operation
    def update_task_board(self, checkpoint_manager):
        """
        Update the task board with checkpoint protection.
        
        This demonstrates using the checkpoint_operation decorator for a critical
        task management operation.
        """
        logger.info("Updating task board...")
        
        # Simulate loading tasks
        self._mock_load_tasks()
        
        # Add task board update to memory
        self.memory["short_term"].append({
            "action": "update_task_board",
            "timestamp": time.time(),
            "task_counts": {
                "pending": len(self.task_board["pending_tasks"]),
                "in_progress": len(self.task_board["in_progress_tasks"]),
                "completed": len(self.task_board["completed_tasks"])
            }
        })
        
        logger.info("Task board updated")
        
    def assign_task(self, task_id: str, agent_id: str):
        """
        Assign a task to an agent with checkpoint protection.
        
        This demonstrates manual checkpoint creation for task assignment.
        """
        logger.info(f"Assigning task {task_id} to {agent_id}...")
        
        # Create pre-operation checkpoint
        pre_op_checkpoint = self.checkpoint_manager.create_checkpoint("pre_operation")
        logger.info(f"Created pre-operation checkpoint: {pre_op_checkpoint}")
        
        try:
            # Check if task is locked
            if task_id in self.task_locks:
                raise RuntimeError(f"Task {task_id} is locked and cannot be assigned")
                
            # Lock the task
            self.task_locks.add(task_id)
            
            # Simulate task assignment
            # Find the task in pending tasks
            task_to_assign = None
            for task in self.task_board["pending_tasks"]:
                if task["task_id"] == task_id:
                    task_to_assign = task
                    break
                    
            if task_to_assign:
                # Remove from pending
                self.task_board["pending_tasks"].remove(task_to_assign)
                
                # Add assignment details
                task_to_assign["assigned_to"] = agent_id
                task_to_assign["assignment_time"] = time.time()
                
                # Add to in_progress
                self.task_board["in_progress_tasks"].append(task_to_assign)
                
                # Update metrics
                if agent_id not in self.task_metrics["assignment_counts"]:
                    self.task_metrics["assignment_counts"][agent_id] = 0
                self.task_metrics["assignment_counts"][agent_id] += 1
                
                logger.info(f"Task {task_id} assigned to {agent_id}")
            else:
                logger.warning(f"Task {task_id} not found in pending tasks")
                
            # Unlock the task
            self.task_locks.remove(task_id)
            
            # Create post-operation checkpoint
            post_op_checkpoint = self.checkpoint_manager.create_checkpoint("post_operation")
            logger.info(f"Created post-operation checkpoint: {post_op_checkpoint}")
            
        except Exception as e:
            # Create recovery checkpoint on error
            recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
            logger.error(f"Error assigning task: {str(e)}")
            logger.info(f"Recovery checkpoint created: {recovery_checkpoint}")
            
            # Clean up lock if needed
            if task_id in self.task_locks:
                self.task_locks.remove(task_id)
                
    def operational_loop(self):
        """
        Main operational loop with checkpoint integration.
        
        This demonstrates a complete integration of checkpointing into
        the Task Agent's operational loop.
        """
        logger.info("Starting Task Agent operational loop...")
        
        # Main operational loop
        while True:  # In real implementation, there would be a proper exit condition
            try:
                # 1. Process mailbox
                self.process_mailbox(self.checkpoint_manager)
                
                # 2. Update task board
                self.update_task_board(self.checkpoint_manager)
                
                # 3. Process task assignments (example operation)
                if self.task_board["pending_tasks"]:
                    # Assign a task from pending to an agent
                    task_to_assign = self.task_board["pending_tasks"][0]
                    agent_id = "Agent-3"  # Example agent
                    self.assign_task(task_to_assign["task_id"], agent_id)
                
                # 4. Regular checkpoint creation
                self.last_checkpoint_time = check_and_create_checkpoint(
                    self.checkpoint_manager,
                    self.last_checkpoint_time
                )
                
                # 5. Check for session refresh to prevent drift
                current_time = time.time()
                if current_time - self.session_start_time >= 7200:  # 2 hours
                    logger.info("Session duration exceeds 2 hours, initiating controlled restart")
                    recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
                    controlled_restart(recovery_checkpoint)
                    break  # Exit loop after restart
                    
                # Simulate short delay between operations
                time.sleep(5)
                
            except Exception as e:
                # Create recovery checkpoint on error
                recovery_checkpoint = self.checkpoint_manager.create_checkpoint("recovery")
                logger.error(f"Error during operation: {str(e)}")
                logger.info(f"Recovery checkpoint created: {recovery_checkpoint}")
                
                # Continue loop instead of breaking (resilience)
                continue
                
        logger.info("Task Agent operational loop terminated")

if __name__ == "__main__":
    # Create and run the Task Agent
    task_agent = TaskAgent()
    task_agent.operational_loop() 