\"\"\"Dream.OS Deployment Script - Cursor Listener Deployment Orchestrator\"\"\"\n\nimport asyncio\nimport json\nimport logging\nimport os\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# NOTE: Removed unused imports: pytest, text_string_to_metric_families\n# import pytest\n# from prometheus_client.parser import text_string_to_metric_families\nimport yaml\n\n# Adjust imports based on new location (assuming scripts/ is added to PYTHONPATH or run relative to root)\n# Need to ensure core and _agent_coordination are importable\nfrom core.config import config_service\nfrom core.feedback import log_event\nfrom core.utils.command import CommandExecutor\nfrom core.utils.file_manager import FileManager\nfrom core.utils.system import SystemUtils\n\nAGENT_ID = \"DeploymentScript\" # Changed from Agent\nCURSOR_METRICS = [\n    \"cursor_execution_results\",\n    \"cursor_error_types\",\n    \"cursor_retry_attempts\",\n    \"cursor_processing_duration_seconds\",\n    \"cursor_queue_size\"\n]\n\nclass CursorListenerDeployer: # Renamed class\n    \"\"\"Orchestrates the deployment of the Cursor Result Listener.\"\"\"\n\n    def __init__(self):\n        self.cmd = CommandExecutor()\n        self.file_mgr = FileManager()\n        self.sys_utils = SystemUtils()\n        # Assume config service loads appropriate config or adjust path\n        # self.config = self._load_config() # Loading via config_service might be better\n        self.config = config_service.load_config(\"cursor.yaml\") # Assuming config_service can load specific files\n        if not self.config or \"cursor\" not in self.config:\n            raise ValueError(\"Failed to load cursor configuration from config service.\")\n\n        self.feedback_dir = Path(self.config[\"cursor\"][\"feedback_dir\"])\n\n    # Removed _load_config - assuming config_service handles this\n\n    async def run_tests(self) -> bool:\n        \"\"\"Execute test suite and verify coverage.\"\"\"\n        log_event(\"TESTS_STARTED\", AGENT_ID, {\"component\": \"cursor_listener\"})\n\n        # Run pytest with coverage - Ensure test path and cov path are correct\n        # TODO: Verify test path and cov target path after consolidation\n        test_path = \"tests/_agent_coordination/tools/test_cursor_result_listener.py\" # Example adjusted path\n        cov_target = \"_agent_coordination.tools.cursor_result_listener\" # Source path for coverage\n        result = await self.cmd.run_command(\n            f\"pytest {test_path} -v --cov={cov_target} --cov-report=html\"\n        )\n\n        if \"failed\" in result.lower():\n            log_event(\"TESTS_FAILED\", AGENT_ID, {\"output\": result})\n            return False\n\n        # Verify coverage threshold\n        # TODO: Confirm path to coverage report\n        try:\n            cov_report = Path(\"htmlcov/index.html\").read_text()\n            if \"90%\" not in cov_report: # TODO: Make threshold configurable?\n                log_event(\"COVERAGE_INSUFFICIENT\", AGENT_ID, {\"threshold\": \"90%\"})\n                return False\n        except FileNotFoundError:\n            log_event(\"COVERAGE_REPORT_NOT_FOUND\", AGENT_ID, {\"path\": \"htmlcov/index.html\"})\n            # Decide if this is a failure or just a warning\n            return False # Treat as failure for now\n\n        log_event(\"TESTS_PASSED\", AGENT_ID, {\"coverage\": \"â‰¥90%\"})\n        return True\n\n    async def prepare_system(self) -> bool:\n        \"\"\"Prepare system directories and permissions.\"\"\"\n        try:\n            # Create directory structure\n            dirs = [\n                self.config[\"cursor\"][key] for key in\n                [\"pending_dir\", \"processing_dir\", \"archive_dir\", \"error_dir\", \"feedback_dir\"]\n            ]\n\n            for dir_path_str in dirs:\n                dir_path = Path(dir_path_str)\n                dir_path.mkdir(parents=True, exist_ok=True)\n                # Note: chmod might fail without sudo\n                try:\n                    os.chmod(dir_path, 0o755)\n                except PermissionError:\n                    log_event(\"PERMISSION_ERROR\", AGENT_ID, {\"action\": \"chmod\", \"path\": str(dir_path)}, level=\"warning\")\n\n            # Configure log rotation\n            # Note: Writing to /etc requires root privileges\n            logrotate_config = f\"\"\"\n            {self.config['cursor']['log_file']} {{\n                daily\n                rotate 14\n                compress\n                delaycompress\n                notifempty\n                create 0644 dream dream # User/Group might need adjustment\n            }}\n            \"\"\"\n            try:\n                Path(\"/etc/logrotate.d/cursor-listener\").write_text(logrotate_config)\n            except PermissionError:\n                log_event(\"PERMISSION_ERROR\", AGENT_ID, {\"action\": \"write_logrotate\", \"path\": \"/etc/logrotate.d/cursor-listener\"}, level=\"warning\")\n                # Consider logging this as a manual step required\n\n            log_event(\"SYSTEM_PREPARED\", AGENT_ID, {\"directories\": dirs})\n            return True\n\n        except Exception as e:\n            log_event(\"SYSTEM_PREP_FAILED\", AGENT_ID, {\"error\": str(e)})\n            return False\n\n    async def backup_existing(self) -> bool:\n        \"\"\"Create backups of existing data.\"\"\"\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            backup_base_dir = Path(\"backups/cursor_listener\") # Centralized backup location\n            backup_dir = backup_base_dir / timestamp\n            backup_dir.mkdir(parents=True, exist_ok=True)\n\n            # Backup context file\n            context_file = Path(self.config[\"cursor\"][\"context_file\"])\n            if context_file.exists():\n                backup_path = backup_dir / context_file.name\n                self.file_mgr.safe_copy(context_file, backup_path)\n\n            # Archive logs\n            log_file = Path(self.config[\"cursor\"][\"log_file\"])\n            if log_file.exists():\n                backup_path = backup_dir / log_file.name\n                self.file_mgr.safe_copy(log_file, backup_path)\n\n            # Snapshot metrics (if service is running)\n            try:\n                metrics_response = await self.cmd.run_command(\n                    f\"curl -s localhost:{self.config['cursor']['metrics_port']}/metrics\"\n                )\n                if metrics_response:\n                     metrics_path = backup_dir / \"cursor_metrics.txt\"\n                     metrics_path.write_text(metrics_response)\n            except Exception as curl_err:\n                 log_event(\"METRICS_SNAPSHOT_FAILED\", AGENT_ID, {\"error\": str(curl_err)}, level=\"warning\")\n\n            log_event(\"BACKUP_CREATED\", AGENT_ID, {\"timestamp\": timestamp, \"location\": str(backup_dir)})\n            return True\n\n        except Exception as e:\n            log_event(\"BACKUP_FAILED\", AGENT_ID, {\"error\": str(e)})\n            return False\n\n    async def deploy_service(self) -> bool:\n        \"\"\"Deploy and start the Cursor Listener service using systemd.\"\"\"\n        # Note: All systemctl commands typically require sudo\n        service_name = \"cursor-listener\"\n        service_file_path = Path(f\"/etc/systemd/system/{service_name}.service\")\n        # Assume project root is WORKSPACE_ROOT env var or similar\n        project_root = Path(os.getenv(\"WORKSPACE_ROOT\", Path.cwd()))\n        listener_module_path = \"_agent_coordination.tools.cursor_result_listener\"\n        python_executable = sys.executable # Use the same python that runs this script\n\n        try:\n            # Stop existing service\n            await self.cmd.run_command(f\"sudo systemctl stop {service_name}\", check=False)\n\n            # Update systemd service file\n            # User/Group might need adjustment\n            # Ensure WORKSPACE_ROOT is correct in the target environment\n            service_config = f\"\"\"\n            [Unit]\n            Description=Dream OS Cursor Result Listener\n            After=network.target\n\n            [Service]\n            Type=simple\n            User=dream\n            Group=dream\n            WorkingDirectory={str(project_root)}\n            ExecStart={python_executable} -m {listener_module_path}\n            Restart=always\n            RestartSec=5\n            Environment=\"PYTHONPATH={str(project_root)}\"\n\n            [Install]\n            WantedBy=multi-user.target\n            \"\"\"\n\n            try:\n                # Requires sudo\n                with open(service_file_path, \"w\") as f:\n                    f.write(service_config)\n                await self.cmd.run_command(f\"sudo chmod 644 {str(service_file_path)}\")\n            except PermissionError:\n                 log_event(\"PERMISSION_ERROR\", AGENT_ID, {\"action\": \"write_systemd\", \"path\": str(service_file_path)}, level=\"error\")\n                 return False # Cannot proceed without writing service file\n\n            # Reload systemd and start service\n            await self.cmd.run_command(\"sudo systemctl daemon-reload\")\n            await self.cmd.run_command(f\"sudo systemctl enable {service_name}\") # Enable on boot\n            await self.cmd.run_command(f\"sudo systemctl start {service_name}\")\n\n            # Verify service status briefly\n            await asyncio.sleep(2) # Give service time to start\n            status = await self.cmd.run_command(f\"systemctl is-active {service_name}\", check=False)\n            if \"active\" not in status.lower():\n                raise RuntimeError(f\"Service \'{service_name}\' failed to start. Status: {status}\")\n\n            log_event(\"SERVICE_DEPLOYED\", AGENT_ID, {\"service\": service_name, \"status\": \"active\"})\n            return True\n\n        except Exception as e:\n            log_event(\"DEPLOYMENT_FAILED\", AGENT_ID, {\"error\": str(e)})\n            # Attempt to get more logs if failed\n            try:\n                journal_logs = await self.cmd.run_command(f\"sudo journalctl -u {service_name} -n 50 --no-pager | cat\", check=False)\n                log_event(\"SERVICE_STARTUP_LOGS\", AGENT_ID, {\"logs\": journal_logs})\n            except Exception:\
                    pass # Ignore if getting logs fails\n            return False\n\n    async def verify_deployment(self) -> bool:\n        \"\"\"Run post-deployment verification checks.\"\"\"\n        service_name = \"cursor-listener\"\n        try:\n            # Check service status\n            status = await self.cmd.run_command(f\"systemctl status {service_name} | cat\")\n            if \"active (running)\" not in status:\n                raise RuntimeError(f\"Service \'{service_name}\' not running. Status: {status}\")\n\n            # Check logs for errors\n            # Using journalctl requires permissions or sudo\n            logs = await self.cmd.run_command(f\"sudo journalctl -u {service_name} -n 50 --no-pager | cat\")\n            if \"error\" in logs.lower() or \"exception\" in logs.lower():\n                 log_event(\"SERVICE_LOG_ERRORS\", AGENT_ID, {\"logs\": logs}, level=\"warning\")\n                 # Decide if this is fatal - maybe not if service is running?\n\n            # Verify metrics endpoint\n            try:\n                metrics_check = await self.cmd.run_command(\n                    f\"curl -s --fail localhost:{self.config['cursor']['metrics_port']}/-/healthy\"\n                )\n                 # Check if curl command succeeded (exit code 0)\n                 # Note: run_command needs modification to return exit codes or raise on error if check=True\n                 # Assuming run_command raises exception on failure for now\n            except Exception as curl_err:\n                 raise RuntimeError(f\"Metrics endpoint not healthy: {curl_err}\")\n\n            # Test file processing\n            test_prompt = {\n                \"prompt_id\": \"deploy_verify_test\",\n                \"prompt_text\": \"Deployment verification test prompt\",\n                \"source_agent\": AGENT_ID\n            }\n            # Use Path object for paths\n            pending_dir = Path(self.config[\"cursor\"][\"pending_dir\"])\n            test_file = pending_dir / f\"{test_prompt['prompt_id']}.json\"\n            test_file.write_text(json.dumps(test_prompt))\n            log_event(\"VERIFICATION_TEST_FILE_SENT\", AGENT_ID, {\"file\": str(test_file)})\n\n            # Wait for processing (adjust time as needed)\n            await asyncio.sleep(int(self.config[\"cursor\"].get(\"poll_interval\", 5)) + 5)\n\n            # Verify feedback by checking for a file corresponding to the prompt_id\n            feedback_dir = Path(self.config[\"cursor\"][\"feedback_dir\"])\n            expected_feedback_file = feedback_dir / f\"{test_prompt['prompt_id']}_result.json\" # Assume result naming convention\n\n            if not expected_feedback_file.exists():\n                 # Check error directory as well\n                 error_dir = Path(self.config[\"cursor\"][\"error_dir\"])\n                 error_file = error_dir / f\"{test_prompt['prompt_id']}.json\"\n                 if error_file.exists():\n                     raise RuntimeError(f\"Test prompt resulted in error: {error_file.read_text()}\")\n                 else:\n                     raise RuntimeError(f\"Feedback file not generated: {expected_feedback_file}\")\n            else:\n                 log_event(\"VERIFICATION_FEEDBACK_RECEIVED\", AGENT_ID, {\"file\": str(expected_feedback_file)})\n\n            log_event(\"DEPLOYMENT_VERIFIED\", AGENT_ID, {\"status\": \"success\"})\n            return True\n\n        except Exception as e:\n            log_event(\"VERIFICATION_FAILED\", AGENT_ID, {\"error\": str(e)})\n            return False\n\n    async def deploy(self) -> bool:\n        \"\"\"Execute full deployment process.\"\"\"\n        steps = [\n            (self.run_tests, \"Test Execution\"),\n            (self.backup_existing, \"Backup Creation\"),\n            (self.prepare_system, \"System Preparation\"),\n            (self.deploy_service, \"Service Deployment\"),\n            (self.verify_deployment, \"Deployment Verification\")\n        ]\n\n        overall_success = True\n        for step_func, step_name in steps:\n            log_event(\"STEP_STARTED\", AGENT_ID, {\"step\": step_name})\n            success = await step_func()\n            if not success:\n                log_event(\"STEP_FAILED\", AGENT_ID, {\"step\": step_name}, level=\"error\")\n                overall_success = False\n                # Decide whether to stop on failure\n                # break # Uncomment to stop on first failure\n            else:\n                 log_event(\"STEP_SUCCEEDED\", AGENT_ID, {\"step\": step_name})\n\n        final_status = \"Succeeded\" if overall_success else \"Failed\"\n        log_event(\"DEPLOYMENT_FINISHED\", AGENT_ID, {\"status\": final_status})\n        return overall_success\n\nasync def main():\n    # Setup basic logging if run as script\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n    deployer = CursorListenerDeployer()\n    success = await deployer.deploy()\n    sys.exit(0 if success else 1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main()) 