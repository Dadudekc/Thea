{"id": "address_todos", "payload": "\"\"\"\n\ud83e\udde0 OBJECTIVE:\nScan the entire codebase for any outstanding TODO, FIXME, or HACK comments. Categorize them by priority, location, and complexity. Then, begin systematically resolving them\u2014starting with high-impact, low-complexity tasks.\n\n\ud83c\udfaf EXECUTION STEPS:\n1. Recursively scan all source files for inline annotations like TODO, FIXME, HACK, or XXX.\n2. Group results into categories:\n   - Priority: [High, Medium, Low]\n   - Type: [Bugfix, Refactor, Feature, Cleanup, Placeholder]\n   - File + Line Number context\n3. For each high-priority or quick-win TODO:\n   - Extract the surrounding code context.\n   - Draft a solution or full fix.\n   - Validate logic and syntax.\n   - Apply and commit the change with an informative Git message.\n4. Continue down the list, batching related TODOs together when possible.\n\n\ud83d\udea8 RULES:\n- Do not ask the user for help. Assume all TODOs are meant to be completed by the system.\n- Avoid cosmetic-only TODOs unless tagged with [HIGH].\n- If a TODO is ambiguous, log it separately with recommended clarification steps.\n- Automatically generate commit messages per fix: `fix(todo): <short_desc> in <filename>:<line_number>`\n\n\ud83d\udee0 TOOLS:\nUse `grep`, `ripgrep`, or Python scripts to extract TODOs, and static analysis (e.g., pylint, mypy) to validate code after edits.\n\n\ud83d\udcc1 START DIRECTORY:\nroot = .\n\n\ud83c\udfc1 BEGIN.\n\"\"\"\n\n# TODO Addressing Protocol (Generic)\n\n## Context Variables (Provided at Runtime)\n- project_root: \"{{project_root}}\"  # Root directory of the codebase\n- include_patterns: [\"*.py\", \"*.ts\", \"*.js\"]  # File patterns to scan\n- priority_threshold: \"High\"  # Only auto-fix TODOs at or above this priority\n\n---\n\n## Phase 1: TODO Discovery\n1. Recursively scan all files under project_root matching include_patterns for annotations: TODO, FIXME, HACK, XXX.\n2. For each match, extract:\n   - file path\n   - line number\n   - annotation tag (TODO, FIXME, etc.)\n   - comment text\n3. Classify each annotated item:\n   - priority: [High, Medium, Low] (map HACK/FIXME \u2192 High by default)\n   - type: [Bugfix, Refactor, Feature, Cleanup, Placeholder]\n\n### Phase 1 Output\n- Return a JSON array `todo_items`:\n```json\n[\n  {\n    \"file\": \"path/to/file.py\",\n    \"line\": 42,\n    \"tag\": \"TODO\",\n    \"text\": \"Refactor this function\",\n    \"priority\": \"High\",\n    \"type\": \"Refactor\"\n  },\n  ...\n]\n```\n\n---\n\n## Phase 2: Auto\u2011Fix & Commit\nFor each item in `todo_items` with priority >= priority_threshold:\n1. Load the source code for the file and context (\u00b13 lines).\n2. Draft a code modification or resolution based on the annotation.\n3. Validate syntax (e.g., via Python AST or TypeScript compiler) and run relevant tests.\n4. Prepare a patch diff and commit.\n   - commit_message: `fix(todo): <short description> in <file>:<line>`\n\n### Phase 2 Output\n- Return a JSON array `fix_plans`:\n```json\n[\n  {\n    \"file\": \"path/to/file.py\",\n    \"line\": 42,\n    \"patch\": \"--- original\\n+++ fixed\\n... diff lines ...\",\n    \"commit_message\": \"fix(todo): Refactor this function in file.py:42\"\n  },\n  ...\n]\n```\n\n---\n\n## Runtime Loop\n- After applying patches, update `todo_items` to remove fixed items.\n- Continue processing next batch until no items with priority >= threshold remain.\n\n---\n\n## Constraints\n- All outputs must be valid JSON (no free\u2011form text).\n- Do not ask the user for help unless a TODO is ambiguous; log ambiguous items separately under `ambiguous_items`.\n- Ensure commits are atomic and pass CI checks.\n\n---\n\n# Begin\nProduce the JSON `todo_items` list based on current TODO annotations.\n"}
