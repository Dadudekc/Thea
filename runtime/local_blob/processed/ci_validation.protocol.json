{"id": "ci_validation.protocol", "payload": "# CI Validation Protocol (Generic v1)\n\n## Context Variables (Provided at Runtime)\n- project_root: \"{{project_root}}\"         # Root directory of codebase\n- test_pattern: \"{{test_pattern}}\"       # Pytest pattern or path (e.g., \"tests/\")\n- priority_mapping: {\"error\":\"High\", \"warning\":\"Medium\", \"skipped\":\"Low\"}  # Map failure types to priorities\n- human_only_patterns: [\"TODO\",\"FIXME\"]  # Strings indicating human-only follow-ups\n- tools: [\"run_command\", \"read_file\", \"search\"]\n\n---\n\n## Phase 1: Execute Tests\n1. Run `pytest` with `test_pattern`.\n2. Capture exit_code, stdout, stderr.\n\n### Phase 1 Output\n```json\n{\n  \"phase\": \"run_tests\",\n  \"exit_code\": <int>,\n  \"stdout\": \"<output>\",\n  \"stderr\": \"<errors>\"\n}\n```\n\n---\n\n## Phase 2: Parse Failures\n1. If exit_code == 0, stop with pass status.\n2. Else, for each failure block in stdout/stderr:\n   - Extract `file`, `line`, `error_type` (AssertionError, ImportError, etc.)\n   - Determine `severity`: map error_type to priority_mapping\n   - Determine `human_only`: True if failure message contains any human_only_patterns\n\n### Phase 2 Output\n```json\n{\n  \"phase\": \"parse_failures\",\n  \"failures\": [\n    {\"file\":\"path/to.py\",\"line\":42,\"error_type\":\"AssertionError\",\"priority\":\"High\",\"human_only\":false},\n    ...\n  ]\n}\n```\n\n---\n\n## Phase 3: Task Creation\nFor each failure in `failures`:\n- Create a task object:\n  {\"task_id\":\"<unique>\", \"type\":\"fix_test\", \"file\":\"...\",\"line\":.., \"priority\":\"...\",\"human_only\":...}\n\n### Phase 3 Output\n```json\n{\n  \"phase\": \"create_tasks\",\n  \"tasks\": [ { ... }, ... ]\n}\n```\n\n---\n\n## Constraints\n- All outputs valid JSON.\n- Halt with need_clarification if essential context missing:\n```json\n{\"phase\":\"need_clarification\",\"missing\":[\"<info>\"]}\n```\n\n---\n\n# Begin\nProduce Phase 1 JSON by running tests. "}
