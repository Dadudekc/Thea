{"id": "initiate_cleanup", "payload": "# Cleanup Initiation Protocol (Generic v2)\n\n## Context Variables (Provided at Runtime)\n- project_root: \"{{project_root}}\"        # Root directory of the codebase\n- include_patterns: [\"*.py\", \"*.js\", \"*.ts\"]  # File patterns to scan\n- categories: [\"duplicate\", \"bloat\", \"fragmentation\", \"dead_code\", \"drift\"]\n- priority_order: [\"duplicate\", \"bloat\", \"fragmentation\", \"drift\", \"dead_code\"]\n- max_items: {{max_items}}                # Max items to process in this run\n\n---\n\n## Phase 1: Cleanup Scan\n1. Recursively scan project_root for files matching include_patterns.\n2. For each file, identify issues based on categories.\n3. Assemble list `cleanup_candidates` sorted by priority_order.\n\n### Phase 1 Output\nReturn a JSON array `cleanup_candidates`:\n```json\n[\n  {\"file\": \"path/to/file.py\", \"category\": \"duplicate\", \"line_range\": [10,20], \"description\": \"Duplicate function found\"},\n  ...\n]\n```\n\n---\n\n## Phase 2: Generate Actions\nFor the first up to `max_items` in `cleanup_candidates`:\n1. Create an action plan with an `action` and `context`, e.g.,\n   - `remove_dead_code`, `merge_modules`, `rename_entities`, etc.\n2. Include any required `paths` or code snippets.\n\n### Phase 2 Output\nReturn a JSON array `action_plans`:\n```json\n[\n  {\"file\": \"path/to/file.py\", \"action\": \"remove_dead_code\", \"line_range\": [30,40]},\n  ...\n]\n```\n\n---\n\n## Phase 3: Execute and Validate\n- Apply each plan using the appropriate tool (e.g., `edit_file`).\n- Validate changes (lint, tests).\n- Collect results into `cleanup_results`.\n\n### Phase 3 Output\nReturn a JSON object:\n```json\n{\n  \"phase\": \"complete\",\n  \"fixed_count\": 3,\n  \"errors\": []\n}\n```\n\n---\n\n# Begin\nProduce the **Phase 1** JSON array `cleanup_candidates` based on the current codebase scan.\n"}
