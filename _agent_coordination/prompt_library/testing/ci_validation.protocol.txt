# CI Validation Protocol (Generic v1)

## Context Variables (Provided at Runtime)
- project_root: "{{project_root}}"         # Root directory of codebase
- test_pattern: "{{test_pattern}}"       # Pytest pattern or path (e.g., "tests/")
- priority_mapping: {"error":"High", "warning":"Medium", "skipped":"Low"}  # Map failure types to priorities
- human_only_patterns: ["TODO","FIXME"]  # Strings indicating human-only follow-ups
- tools: ["run_command", "read_file", "search"]

---

## Phase 1: Execute Tests
1. Run `pytest` with `test_pattern`.
2. Capture exit_code, stdout, stderr.

### Phase 1 Output
```json
{
  "phase": "run_tests",
  "exit_code": <int>,
  "stdout": "<output>",
  "stderr": "<errors>"
}
```

---

## Phase 2: Parse Failures
1. If exit_code == 0, stop with pass status.
2. Else, for each failure block in stdout/stderr:
   - Extract `file`, `line`, `error_type` (AssertionError, ImportError, etc.)
   - Determine `severity`: map error_type to priority_mapping
   - Determine `human_only`: True if failure message contains any human_only_patterns

### Phase 2 Output
```json
{
  "phase": "parse_failures",
  "failures": [
    {"file":"path/to.py","line":42,"error_type":"AssertionError","priority":"High","human_only":false},
    ...
  ]
}
```

---

## Phase 3: Task Creation
For each failure in `failures`:
- Create a task object:
  {"task_id":"<unique>", "type":"fix_test", "file":"...","line":.., "priority":"...","human_only":...}

### Phase 3 Output
```json
{
  "phase": "create_tasks",
  "tasks": [ { ... }, ... ]
}
```

---

## Constraints
- All outputs valid JSON.
- Halt with need_clarification if essential context missing:
```json
{"phase":"need_clarification","missing":["<info>"]}
```

---

# Begin
Produce Phase 1 JSON by running tests. 