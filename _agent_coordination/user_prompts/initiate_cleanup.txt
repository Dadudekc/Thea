# Cleanup Initiation Protocol (Generic v2)

## Context Variables (Provided at Runtime)
- project_root: "{{project_root}}"        # Root directory of the codebase
- include_patterns: ["*.py", "*.js", "*.ts"]  # File patterns to scan
- categories: ["duplicate", "bloat", "fragmentation", "dead_code", "drift"]
- priority_order: ["duplicate", "bloat", "fragmentation", "drift", "dead_code"]
- max_items: {{max_items}}                # Max items to process in this run

---

## Phase 1: Cleanup Scan
1. Recursively scan project_root for files matching include_patterns.
2. For each file, identify issues based on categories.
3. Assemble list `cleanup_candidates` sorted by priority_order.

### Phase 1 Output
Return a JSON array `cleanup_candidates`:
```json
[
  {"file": "path/to/file.py", "category": "duplicate", "line_range": [10,20], "description": "Duplicate function found"},
  ...
]
```

---

## Phase 2: Generate Actions
For the first up to `max_items` in `cleanup_candidates`:
1. Create an action plan with an `action` and `context`, e.g.,
   - `remove_dead_code`, `merge_modules`, `rename_entities`, etc.
2. Include any required `paths` or code snippets.

### Phase 2 Output
Return a JSON array `action_plans`:
```json
[
  {"file": "path/to/file.py", "action": "remove_dead_code", "line_range": [30,40]},
  ...
]
```

---

## Phase 3: Execute and Validate
- Apply each plan using the appropriate tool (e.g., `edit_file`).
- Validate changes (lint, tests).
- Collect results into `cleanup_results`.

### Phase 3 Output
Return a JSON object:
```json
{
  "phase": "complete",
  "fixed_count": 3,
  "errors": []
}
```

---

# Begin
Produce the **Phase 1** JSON array `cleanup_candidates` based on the current codebase scan.
