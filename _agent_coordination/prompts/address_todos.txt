"""
🧠 OBJECTIVE:
Scan the entire codebase for any outstanding TODO, FIXME, or HACK comments. Categorize them by priority, location, and complexity. Then, begin systematically resolving them—starting with high-impact, low-complexity tasks.

🎯 EXECUTION STEPS:
1. Recursively scan all source files for inline annotations like TODO, FIXME, HACK, or XXX.
2. Group results into categories:
   - Priority: [High, Medium, Low]
   - Type: [Bugfix, Refactor, Feature, Cleanup, Placeholder]
   - File + Line Number context
3. For each high-priority or quick-win TODO:
   - Extract the surrounding code context.
   - Draft a solution or full fix.
   - Validate logic and syntax.
   - Apply and commit the change with an informative Git message.
4. Continue down the list, batching related TODOs together when possible.

🚨 RULES:
- Do not ask the user for help. Assume all TODOs are meant to be completed by the system.
- Avoid cosmetic-only TODOs unless tagged with [HIGH].
- If a TODO is ambiguous, log it separately with recommended clarification steps.
- Automatically generate commit messages per fix: `fix(todo): <short_desc> in <filename>:<line_number>`

🛠 TOOLS:
Use `grep`, `ripgrep`, or Python scripts to extract TODOs, and static analysis (e.g., pylint, mypy) to validate code after edits.

📁 START DIRECTORY:
root = .

🏁 BEGIN.
"""

# TODO Addressing Protocol (Generic)

## Context Variables (Provided at Runtime)
- project_root: "{{project_root}}"  # Root directory of the codebase
- include_patterns: ["*.py", "*.ts", "*.js"]  # File patterns to scan
- priority_threshold: "High"  # Only auto-fix TODOs at or above this priority

---

## Phase 1: TODO Discovery
1. Recursively scan all files under project_root matching include_patterns for annotations: TODO, FIXME, HACK, XXX.
2. For each match, extract:
   - file path
   - line number
   - annotation tag (TODO, FIXME, etc.)
   - comment text
3. Classify each annotated item:
   - priority: [High, Medium, Low] (map HACK/FIXME → High by default)
   - type: [Bugfix, Refactor, Feature, Cleanup, Placeholder]

### Phase 1 Output
- Return a JSON array `todo_items`:
```json
[
  {
    "file": "path/to/file.py",
    "line": 42,
    "tag": "TODO",
    "text": "Refactor this function",
    "priority": "High",
    "type": "Refactor"
  },
  ...
]
```

---

## Phase 2: Auto‑Fix & Commit
For each item in `todo_items` with priority >= priority_threshold:
1. Load the source code for the file and context (±3 lines).
2. Draft a code modification or resolution based on the annotation.
3. Validate syntax (e.g., via Python AST or TypeScript compiler) and run relevant tests.
4. Prepare a patch diff and commit.
   - commit_message: `fix(todo): <short description> in <file>:<line>`

### Phase 2 Output
- Return a JSON array `fix_plans`:
```json
[
  {
    "file": "path/to/file.py",
    "line": 42,
    "patch": "--- original\n+++ fixed\n... diff lines ...",
    "commit_message": "fix(todo): Refactor this function in file.py:42"
  },
  ...
]
```

---

## Runtime Loop
- After applying patches, update `todo_items` to remove fixed items.
- Continue processing next batch until no items with priority >= threshold remain.

---

## Constraints
- All outputs must be valid JSON (no free‑form text).
- Do not ask the user for help unless a TODO is ambiguous; log ambiguous items separately under `ambiguous_items`.
- Ensure commits are atomic and pass CI checks.

---

# Begin
Produce the JSON `todo_items` list based on current TODO annotations.
